import LRItem from "./LRItem";
import { ParsingLog } from "./interfaces/parser.interface";
import { ActionEntry, ActionType, IParsingTable } from "./interfaces/parsingTable.interface";

/**
 * Implementation of SR Parser.
 *
 * @export
 * @class Parser
 */
export default class Parser {
  /**
   * The parsing table to use while parsing.
   *
   * @type {IParsingTable}
   * @memberof Parser
   */
  public parsingTable: IParsingTable;
  /**
   * The parse log while parsing a text with the parser.
   *
   * @type {ParsingLog[]}
   * @memberof Parser
   */
  public parseLog: ParsingLog[];

  /**
   * Creates an instance of Parser.
   * 
   * @param {IParsingTable} parsingTable Parsing table to use.
   * @memberof Parser
   */
  public constructor(parsingTable: IParsingTable) {
    this.parsingTable = parsingTable;
  }

  /**
   * Checks if the sentence is generated by the [[CFG]] represented by [[IParsingTable]]
   * 
   * Stores the [[ParsingLog]] while parsing.
   * 
   * @param {string} sentence To parse
   * @returns {boolean} True if parse successful, otherwise false.
   * @memberof Parser
   */
  public parse(sentence: string): boolean {
    let inputBuffer: string = sentence + '$';
    let inputBufferPtr: number = 0;
    let parseStack: string[] = [];

    let a: string = inputBuffer[inputBufferPtr];
    let startState: string = this.parsingTable.startState.name;

    parseStack.push(startState);
    this.parseLog = [];
    while (true) {
      let tos: string = parseStack[parseStack.length - 1];
      let action: ActionEntry | null = this.parsingTable.ACTION[tos][a];

      this.parseLog.push({
        tos,
        action,
        stack: [...parseStack],
        inputBuffer: inputBuffer.substr(inputBufferPtr)
      });

      if (action) {
        if (action.actionType === ActionType.SHIFT) {
          parseStack.push(action.actionValue.name);
          a = inputBuffer[++inputBufferPtr];
        } else if (action.actionType === ActionType.REDUCE) {
          let prod: LRItem = action.actionValue;
          parseStack.splice(parseStack.length - prod.production.produces.length, prod.production.produces.length);

          let t: string = parseStack[parseStack.length - 1];
          parseStack.push(this.parsingTable.GOTO[t][prod.production.symbol].name);
        } else if (action.actionType === ActionType.ACCEPT) {
          return true;
        }
      } else {
        return false;
      }
    }
  }
}
